(() => {
  // src/utils.js
  const values = (obj) => Object.values(obj ?? {});
  const attempt = (fn, fallback = null) => {
    try {
      return fn();
    } catch {
      return fallback;
    }
  };
  const clone =
    typeof structuredClone === "function"
      ? structuredClone
      : (obj) => (obj ? JSON.parse(JSON.stringify(obj)) : obj);
  const style = (el3, props) => Object.assign(el3.style, props);
  const el = (tag) => document.createElement(tag);
  const floor = Math.floor;

  // src/config.js
  const config = {
    killaura: { delay: 120, range: 6.8, jitterRatio: 0.4 },
    scaffold: { interval: 20 },
    aimbot: { intervalMs: 15, smoothing: 0.12, maxDistance: 8 },
  };

  // src/bloxd.js
  const B = {
    wpRequire: null,
    _noa: null,
    bloxdProps: null,
    get noa() {
      if (!this._noa && this.bloxdProps) {
        this._noa = values(this.bloxdProps).find((p) => p?.entities);
      }
      return this._noa;
    },
    clear() {
      this.wpRequire = null;
      this._noa = null;
      this.bloxdProps = null;
    },
    init(force = false) {
      if (this.wpRequire && !force) return;
      this.clear();
      const descriptors = Object.getOwnPropertyDescriptors(window);
      let chunkKey = Object.keys(descriptors).find((key) => {
        const setter = descriptors[key]?.set;
        return setter && setter.toString().includes("++");
      });
      if (
        !chunkKey &&
        !(chunkKey = Object.keys(window).find((key) => {
          const value = window[key];
          return Array.isArray(value) && typeof value.push === "function";
        }))
      )
        throw new Error("Unable to locate webpack chunk");
      const chunk = window[chunkKey];
      const randomID = Math.floor(Math.random() * 9999999) + 1;
      chunk.push([[randomID], {}, (req) => (this.wpRequire = req)]);
      this.bloxdProps = values(this.findModule("nonBlocksClient:")).find(
        (o) => typeof o === "object"
      );
      this._noa = null;
    },
    findModule(str) {
      if (!this.wpRequire) return null;
      const mods = this.wpRequire.m;
      for (const id in mods) {
        const modFn = mods[id];
        if (modFn && modFn.toString().includes(str)) return this.wpRequire(id);
      }
      return null;
    },
  };
  const getImpKey = () =>
    attempt(() => {
      const entities = B.noa.entities;
      const target = values(entities)[2];
      return Object.entries(entities).find(([, val]) => val === target)?.[0] ?? null;
    });
  const getInventoryContext = () => {
    const noa = B.noa;
    if (!noa) return null;
    const entities = noa.entities;
    const impKey = getImpKey();
    if (!impKey) return null;
    const entity = entities[impKey];
    if (!entity) return null;
    const inventoryWrapper = values(entity).find(
      (value) => value?.list?.[0]?._blockItem
    );
    if (!inventoryWrapper?.list?.length) return null;
    const listItem = inventoryWrapper.list[0];
    return { impKey, entity, inventoryWrapper, listItem };
  };
  const getHeldBlockContext = () => {
    const ctx = getInventoryContext();
    if (!ctx) return null;
    const heldBlock = ctx.listItem?._blockItem;
    if (!heldBlock) return null;
    const playerEntity = values(ctx.listItem).find(
      (value) => typeof value?.checkTargetedBlockCanBePlacedOver === "function"
    );
    if (!playerEntity) return null;
    let worldInstanceKey, worldInstance;
    if (
      !Object.keys(heldBlock).some((key) => {
        const value = heldBlock[key];
        return value && typeof value === "object"
          ? ((worldInstanceKey = key), (worldInstance = value), true)
          : false;
      })
    )
      return null;
    let targetedBlockKey = null;
    let targetedBlock = null;
    Object.keys(worldInstance).some((key) => {
      const value = worldInstance[key];
      return value && typeof value === "object" && (value.normal || value.position)
        ? ((targetedBlockKey = key), (targetedBlock = value), true)
        : false;
    });
    return {
      heldBlock,
      worldInstanceKey,
      worldInstance,
      targetedBlockKey,
      targetedBlock,
      playerEntity,
    };
  };
  const createSpoofedContext = (context, position) => {
    const { heldBlock, worldInstanceKey, worldInstance, targetedBlockKey, targetedBlock } =
      context;
    const safeTarget =
      clone(targetedBlock) || {
        normal: [0, 1, 0],
        position: [...position],
        blockPosition: position.map(floor),
        hitPoint: [...position],
      };
    safeTarget.position = [...position];
    safeTarget.blockPosition = safeTarget.blockPosition ?? position.map(floor);
    safeTarget.normal = safeTarget.normal ?? [0, 1, 0];
    safeTarget.hitPoint = safeTarget.hitPoint ?? [...position];
    return new Proxy(
      {},
      {
        get(_target, prop) {
          if (prop === worldInstanceKey)
            return new Proxy(worldInstance, {
              get(inner, key) {
                return key === targetedBlockKey ? safeTarget : inner[key];
              },
            });
          if (prop === "checkTargetedBlockCanBePlacedOver") return () => true;
          const value = heldBlock[prop];
          return typeof value === "function" ? value.bind(heldBlock) : value;
        },
      }
    );
  };
  const placeSpoofedBlock = (position, context) => {
    const ctx = context ?? getHeldBlockContext();
    return ctx?.heldBlock?.placeBlock
      ? attempt(() => {
          const spoofed = createSpoofedContext(ctx, position);
          ctx.heldBlock.placeBlock.call(spoofed);
          return true;
        }, false)
      : false;
  };

  // src/modules/base.js
  class Module {
    constructor(name) {
      this.name = name;
      this.enabled = false;
    }
    onEnable() {}
    onDisable() {}
    onRender() {}
    toggle() {
      this.enabled ? this.disable() : this.enable();
    }
    enable() {
      if (!this.enabled) {
        this.enabled = true;
        this.onEnable();
      }
    }
    disable() {
      if (this.enabled) {
        this.enabled = false;
        this.onDisable();
      }
    }
  }
  const base_default = Module;

  // src/game.js
  const game = {
    getPosition: (id) => attempt(() => B.noa.entities.getState(id, "position").position),
    getMoveState: (id) => attempt(() => B.noa.entities.getState(id, "movement")),
    get registry() {
      return attempt(() => values(B.noa)[17], {});
    },
    get getSolidity() {
      return values(this.registry)[5];
    },
    get getBlockID() {
      return attempt(
        () => {
          const names = Object.getOwnPropertyNames(B.noa.bloxd.constructor.prototype);
          return B.noa.bloxd[names[3]].bind(B.noa.bloxd);
        },
        () => 0
      );
    },
    getHeldItemGetter() {
      return attempt(() =>
        values(B.noa.entities).find((fn) => {
          if (typeof fn !== "function" || fn.length !== 1) return false;
          const body = fn.toString();
          return body.length < 80 && body.includes(").") && !body.includes("opWrapper");
        })
      );
    },
    safeHeld(id) {
      const getter = this.getHeldItemGetter();
      return getter ? attempt(() => getter(id)) : null;
    },
    get playerList() {
      return attempt(() => {
        const ids = B.noa?.bloxd?.getPlayerIds?.();
        return ids ? Object.values(ids).map(Number).filter((id) => id && id !== 1 && this.safeHeld(id)) : [];
      }, []);
    },
    get doAttack() {
      const held = this.safeHeld(1);
      if (!held) return () => {};
      const attack = held.doAttack || held.breakingItem?.doAttack;
      return attack ? attack.bind(held) : () => {};
    },
    touchingWall() {
      const pos = this.getPosition(1);
      if (!pos) return false;
      const r = 0.35;
      const offsets = [
        [0, 0],
        [r, 0],
        [-r, 0],
        [0, r],
        [0, -r],
        [r, r],
        [r, -r],
        [-r, r],
        [-r, -r],
      ];
      const heights = [0, 1, 2];
      const getId = this.getBlockID;
      for (const [ox, oz] of offsets)
        for (const h of heights) {
          const id = attempt(() => getId(floor(pos[0] + ox), floor(pos[1]) + h, floor(pos[2] + oz)), null);
          if (id !== null && this.getSolidity(id)) return true;
        }
      return false;
    },
    getHeldItemState() {
      return getHeldBlockContext()?.playerEntity?.heldItemState || null;
    },
    getCamera() {
      return attempt(() => B.noa.camera, null);
    },
    getTouchscreenFlag() {
      return attempt(
        () => B.noa.entities.getState(1, "receivesInputs")?.isTouchscreen ?? false,
        false
      );
    },
  };

  // src/math.js
  const math = {
    norm(v) {
      const s = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
      if (!s) return v;
      const i = 1 / Math.sqrt(s);
      return [v[0] * i, v[1] * i, v[2] * i];
    },
    distSq(a, b) {
      const dx = b[0] - a[0];
      const dy = b[1] - a[1];
      const dz = b[2] - a[2];
      return dx * dx + dy * dy + dz * dz;
    },
  };

  // src/modules/killaura.js
  class Killaura extends base_default {
    constructor() {
      super("Killaura");
      this.lastSwing = 0;
    }
    onEnable() {
      this.lastSwing = 0;
    }
    onRender() {
      const now = Date.now();
      const baseDelay = config.killaura.delay;
      const jitter = baseDelay * config.killaura.jitterRatio * (Math.random() - 0.5);
      const effectiveDelay = Math.max(25, baseDelay + jitter);
      if (now - this.lastSwing < effectiveDelay) return;
      this.lastSwing = now;
      const playerPosition = game.getPosition(1);
      if (!playerPosition) return;
      const killRadius = config.killaura.range;
      const killRadiusSq = killRadius * killRadius;
      game.playerList.forEach((playerId) => {
        const enemyPos = game.getPosition(playerId);
        if (!enemyPos || math.distSq(playerPosition, enemyPos) > killRadiusSq) return;
        const vector = math.norm([
          enemyPos[0] - playerPosition[0],
          enemyPos[1] - playerPosition[1],
          enemyPos[2] - playerPosition[2],
        ]);
        try {
          game.doAttack(vector, playerId.toString(), "BodyMesh");
          const safeHeld = game.safeHeld(1);
          safeHeld?.trySwingBlock && safeHeld.trySwingBlock();
          const moveState2 = game.getMoveState(1);
          moveState2?.setArmsAreSwinging && moveState2.setArmsAreSwinging();
        } catch (error) {
          console.debug("[KILLAURA] Killaura attack failed:", error);
          console.error("[KILLAURA] Error details:", error.message, error.stack);
        }
      });
    }
  }
  const killaura_default = Killaura;

  // src/modules/scaffold.js
  class Scaffold extends base_default {
    constructor() {
      super("Scaffold");
      this.interval = null;
    }
    onEnable() {
      this.startInterval();
    }
    onDisable() {
      clearInterval(this.interval);
      this.interval = null;
    }
    startInterval() {
      clearInterval(this.interval);
      const delay = Math.max(5, config.scaffold?.interval ?? 20);
      this.interval = setInterval(() => this.enabled && this.tryPlace(), delay);
      this.tryPlace();
    }
    tryPlace() {
      const context = getHeldBlockContext();
      if (!context?.playerEntity || context.playerEntity.heldItemState?.heldType !== "CubeBlock") return;
      const pos = game.getPosition(1);
      if (!pos) return;
      const blockX = floor(pos[0]);
      const blockY = floor(pos[1]);
      const blockZ = floor(pos[2]);
      const checkPlace = (x, y, z) =>
        attempt(() => context.playerEntity.checkTargetedBlockCanBePlacedOver?.([x, y, z]), false)
          ? true
          : attempt(() => !game.getSolidity(game.getBlockID(x, y, z)), false);
      const target = [blockX, blockY - 1, blockZ];
      if (placeSpoofedBlock(target, context) || (checkPlace(...target) && placeSpoofedBlock(target, context))) return;
      const dx = pos[0] - blockX;
      const dz = pos[2] - blockZ;
      const offsets = [];
      if (dx < 0.3) offsets.push([-1, 0]);
      if (dx > 0.7) offsets.push([1, 0]);
      if (dz < 0.3) offsets.push([0, -1]);
      if (dz > 0.7) offsets.push([0, 1]);
      offsets.some(([ox, oz]) => {
        const coords = [blockX + ox, blockY - 1, blockZ + oz];
        return checkPlace(...coords) && placeSpoofedBlock(coords, context);
      });
    }
  }
  const scaffold_default = Scaffold;

  // src/modules/coordsList.js
  class CoordsList extends base_default {
    constructor() {
      super("CoordsList");
      this.disabled = true;
      this.ondisabled = false;
    }
    onEnable() {
      this.disabled = false;
      this.ondisabled = false;
    }
    onDisable() {
      this.disabled = true;
      this.ondisabled = false;
    }
    onRender() {
      if (!(this.disabled && this.ondisabled) && B?.noa.bloxd?.entityNames)
        try {
          for (const entityId in B.noa.bloxd.entityNames) {
            if (entityId === "1") continue;
            const entityData = B.noa.bloxd.entityNames[entityId];
            const positionData = B.noa.entities?.getState?.(entityId, "position");
            if (!positionData || !positionData.position) continue;
            const position = positionData.position;
            const x = Math.round(position[0]);
            const y = Math.round(position[1]);
            const z = Math.round(position[2]);
            const baseName = entityData.entityName.replace(/\s*\(-?\d+,\s*-?\d+,\s*-?\d+\)$/, "");
            if (!this.ondisabled && this.disabled) {
              entityData.entityName = baseName;
              this.ondisabled = true;
              continue;
            }
            entityData.entityName = `${baseName} (${x}, ${y}, ${z})`;
          }
        } catch (error) {
          console.error("Error updating player coords:", error);
        }
    }
  }
  const coordsList_default = CoordsList;

  // src/modules/esp.js
  class ESP extends base_default {
    constructor() {
      super("ESP");
      this.interval = null;
    }
    update(state) {
      if (!B.noa) return;
      const rendering = values(B.noa)[12];
      if (!rendering) return;
      const thinMeshes = values(rendering).find((value) => value?.thinMeshes)?.thinMeshes;
      if (!Array.isArray(thinMeshes)) return;
      const renderingGroupId = state ? 2 : 0;
      for (const item of thinMeshes) {
        const mesh = item?.meshVariations?.__DEFAULT__?.mesh;
        if (mesh && typeof mesh.renderingGroupId === "number") mesh.renderingGroupId = renderingGroupId;
      }
    }
    onEnable() {
      this.update(true);
      this.interval = setInterval(() => this.update(true), 300);
    }
    onDisable() {
      clearInterval(this.interval);
      this.interval = null;
      this.update(false);
    }
    onRender() {
      if (this.enabled) this.update(true);
    }
  }
  const esp_default = ESP;

  // src/modules/aimbot.js
  class Aimbot extends base_default {
    constructor() {
      super("Aimbot");
      this.interval = null;
      this.lastAimTime = 0;
    }
    angleDiff(e, t) {
      let n = e - t;
      while (n > Math.PI) n -= 2 * Math.PI;
      while (n < -Math.PI) n += 2 * Math.PI;
      return n;
    }
    aimTick() {
      try {
        const now = Date.now();
        if (now - this.lastAimTime < config.aimbot.intervalMs) return;
        this.lastAimTime = now;

        const playerPos = game.getPosition(1);
        if (!playerPos) return;

        const cam = game.getCamera();
        const playerList = game.playerList;
        if (!cam || !playerList) return;

        let best = { id: null, dist: Infinity, heading: 0, pitch: 0 };
        for (const pid of playerList) {
          if (pid === 1) continue;
          const pos = game.getPosition(pid);
          if (!pos) continue;
          const life = attempt(() => B.noa.entities.getState(pid, "genericLifeformState"), null);
          if (life && life.isAlive === false) continue;

          const dx = pos[0] - playerPos[0];
          const dy = pos[1] - playerPos[1];
          const dz = pos[2] - playerPos[2];
          const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
          if (!isFinite(dist) || dist < 1e-3) continue;
          if (dist > config.aimbot.maxDistance) continue;

          const heading = Math.atan2(dx, dz);
          const pitch = -Math.asin(dy / dist);
          if (dist < best.dist) best = { id: pid, dist, heading, pitch };
        }

        if (!best.id) return;
        const smoothing = config.aimbot.smoothing || 0.1;
        const headingDiff = this.angleDiff(best.heading, cam.heading);
        const pitchDiff = best.pitch - cam.pitch;
        cam.heading += headingDiff * smoothing;
        cam.pitch += pitchDiff * smoothing;
      } catch (e) {
        console.error("Aimbot tick error:", e);
        this.onDisable();
        this.enabled = false;
      }
    }
    onEnable() {
      if (!this.interval) {
        this.lastAimTime = 0;
        this.interval = setInterval(() => this.aimTick(), Math.max(5, config.aimbot.intervalMs));
      }
    }
    onDisable() {
      if (this.interval) {
        clearInterval(this.interval);
        this.interval = null;
      }
    }
  }
  const aimbot_default = Aimbot;

  // src/modules/index.js
  const modules = [
    new killaura_default(),
    new scaffold_default(),
    new coordsList_default(),
    new esp_default(),
    new aimbot_default(),
  ];

  // src/ui.js
  const setupUI = (modules2, reinject2) => {
    const listBox = el("div");
    style(listBox, {
      position: "fixed",
      top: "14px",
      left: "14px",
      background: "rgba(15, 17, 26, 0.9)",
      color: "#f8fafc",
      padding: "10px 12px",
      borderRadius: "8px",
      font: "14px 'Inter', system-ui, sans-serif",
      zIndex: 999999,
      boxShadow: "0 10px 30px rgba(0,0,0,0.35)",
      border: "1px solid rgba(255,255,255,0.06)",
      backdropFilter: "blur(6px)",
      minWidth: "160px",
    });
    document.body.appendChild(listBox);

    const toggleBtn = el("button");
    toggleBtn.textContent = "≡";
    style(toggleBtn, {
      position: "fixed",
      top: "14px",
      left: "14px",
      width: "30px",
      height: "30px",
      cursor: "pointer",
      zIndex: 1e6,
      borderRadius: "6px",
      border: "1px solid rgba(255,255,255,0.15)",
      background: "rgba(24, 27, 38, 0.85)",
      color: "#e2e8f0",
      boxShadow: "0 6px 20px rgba(0,0,0,0.3)",
    });
    document.body.appendChild(toggleBtn);

    const gear = el("button");
    gear.textContent = "⚙️";
    style(gear, {
      position: "fixed",
      top: "14px",
      right: "14px",
      cursor: "pointer",
      zIndex: 1e6,
      width: "36px",
      height: "36px",
      borderRadius: "8px",
      border: "1px solid rgba(255,255,255,0.15)",
      background: "rgba(24, 27, 38, 0.85)",
      color: "#e2e8f0",
      boxShadow: "0 6px 20px rgba(0,0,0,0.3)",
    });
    document.body.appendChild(gear);

    const panel2 = el("div");
    style(panel2, {
      position: "fixed",
      top: "60px",
      right: "14px",
      background: "rgba(15,17,26,0.95)",
      color: "#f8fafc",
      padding: "14px",
      borderRadius: "10px",
      font: "13px 'Inter', system-ui, sans-serif",
      zIndex: 1e6,
      display: "none",
      overflow: "auto",
      maxHeight: "70vh",
      boxShadow: "0 14px 40px rgba(0,0,0,0.45)",
      border: "1px solid rgba(255,255,255,0.08)",
      minWidth: "260px",
    });
    panel2.innerHTML = `
      <h2 style="margin:4px 0 8px;font-size:16px;font-weight:700;letter-spacing:0.2px;"><strong>Minin₂</strong></h2>
      <details>
        <summary style="cursor:pointer;font-weight:600;margin:6px 0;">Killaura</summary>
        <div style="padding-left:8px;line-height:1.6;">
          Delay <input id="ka-d" type="number" style="width:70px"> ms<br>
          Range <input id="ka-r" type="number" style="width:70px"><br>
          Jitter Ratio <input id="ka-j" type="number" step="0.05" style="width:70px">
        </div>
      </details>
      <hr style="border:0;border-top:1px solid rgba(255,255,255,0.08);margin:10px 0;">
      <details>
        <summary style="cursor:pointer;font-weight:600;margin:6px 0;">Scaffold</summary>
        <div style="padding-left:8px;line-height:1.6;">
          Delay <input id="sc-i" type="number" style="width:70px"> ms
        </div>
      </details>
      <hr style="border:0;border-top:1px solid rgba(255,255,255,0.08);margin:10px 0;">
      <details>
        <summary style="cursor:pointer;font-weight:600;margin:6px 0;">Aimbot</summary>
        <div style="padding-left:8px;line-height:1.6;">
          Interval <input id="ab-i" type="number" style="width:70px"> ms<br>
          Smoothing <input id="ab-s" type="number" step="0.01" style="width:70px"><br>
          Max Dist <input id="ab-d" type="number" style="width:70px">
        </div>
      </details>
      <hr style="border:0;border-top:1px solid rgba(255,255,255,0.08);margin:10px 0;">
      <button id="manual-reinject" style="width:100%;padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.12);background:linear-gradient(135deg,#2b2f42,#1c1f2e);color:#e2e8f0;cursor:pointer;font-weight:600;">Re-Inject Client</button>
    `;
    document.body.appendChild(panel2);

    const toggleMenu = () => {
      listBox.style.display = listBox.style.display === "none" ? "block" : "none";
    };
    toggleBtn.onclick = toggleMenu;
    gear.onclick = () => {
      panel2.style.display = panel2.style.display === "none" ? "block" : "none";
    };

    const refreshList2 = () => {
      listBox.innerHTML = "";
      modules2.forEach((module) => {
        const row = el("div");
        row.textContent = module.name;
        row.style.cursor = "pointer";
        row.style.font = "15px 'Inter', system-ui, sans-serif";
        row.style.fontWeight = "600";
        row.style.padding = "6px 8px";
        row.style.margin = "2px 0";
        row.style.borderRadius = "6px";
        row.style.display = "flex";
        row.style.alignItems = "center";
        row.style.justifyContent = "space-between";
        row.style.background = module.enabled ? "rgba(74,222,128,0.14)" : "rgba(248,113,113,0.12)";
        row.style.color = module.enabled ? "#4ade80" : "#f87171";
        row.onclick = () => {
          module.toggle();
          refreshList2();
        };
        listBox.appendChild(row);
      });
    };

    panel2.querySelector("#manual-reinject").onclick = () => reinject2(refreshList2);

    return {
      panel: panel2,
      refreshList: refreshList2,
      toggleMenu,
      listBox,
    };
  };

  // src/loop.js
  const startLoop = (modules2) => {
    const loop = () => {
      modules2.forEach((module) => module.enabled && module.onRender());
      requestAnimationFrame(loop);
    };
    loop();
  };

  // src/index.js
  attempt(() => B.init());
  window.minin2 = { B, modules };
  const reinject = (refreshList2) => {
    try {
      B.init(true);
    } catch (error) {
      console.warn("Re-inject init failed", error);
    }
    modules.forEach((module) => {
      if (module.enabled)
        try {
          module.onDisable?.();
        } catch (error) {
          console.debug(`Disable ${module.name} failed`, error);
        }
    });
    modules.forEach((module) => {
      if (module.enabled)
        try {
          module.onEnable?.();
        } catch (error) {
          console.debug(`Enable ${module.name} failed`, error);
        }
    });
    refreshList2();
  };
  const { panel, refreshList, toggleMenu, listBox } = setupUI(modules, reinject);

  const delayInput = panel.querySelector("#ka-d");
  const rangeInput = panel.querySelector("#ka-r");
  const jitterInput = panel.querySelector("#ka-j");
  const scaffoldDelayInput = panel.querySelector("#sc-i");
  const abInterval = panel.querySelector("#ab-i");
  const abSmooth = panel.querySelector("#ab-s");
  const abDist = panel.querySelector("#ab-d");

  if (delayInput) {
    delayInput.value = config.killaura.delay;
    delayInput.onchange = (e) => (config.killaura.delay = +e.target.value);
  }
  if (rangeInput) {
    rangeInput.value = config.killaura.range;
    rangeInput.onchange = (e) => (config.killaura.range = +e.target.value);
  }
  if (jitterInput) {
    jitterInput.value = config.killaura.jitterRatio;
    jitterInput.onchange = (e) => (config.killaura.jitterRatio = +e.target.value);
  }
  if (scaffoldDelayInput) {
    scaffoldDelayInput.value = config.scaffold.interval;
    scaffoldDelayInput.onchange = (e) => (config.scaffold.interval = +e.target.value);
  }
  if (abInterval) {
    abInterval.value = config.aimbot.intervalMs;
    abInterval.onchange = (e) => {
      config.aimbot.intervalMs = Math.max(1, Math.min(100, Math.round(+e.target.value)));
    };
  }
  if (abSmooth) {
    abSmooth.value = config.aimbot.smoothing;
    abSmooth.onchange = (e) => {
      config.aimbot.smoothing = Math.max(0.05, Math.min(1, +e.target.value));
    };
  }
  if (abDist) {
    abDist.value = config.aimbot.maxDistance;
    abDist.onchange = (e) => {
      config.aimbot.maxDistance = Math.max(1, +e.target.value);
    };
  }

  refreshList();
  startLoop(modules);

  // menu visible by default; Right Shift toggles list (UI control only)
  listBox && (listBox.style.display = "block");
})();
